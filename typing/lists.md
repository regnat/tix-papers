Unlike most languages, Nix-light doesn't have a "list" type. Lists are instead a
collection of types.
Indeed, lists aren't monomorphic like they use to be but may contain elements
of arbitrary different types, so even assuming polymorphism, it would be
impossible to express the type of lists as a parametrized type.

<!--- List types may be reduced to the following grammar (modulo the equivalence --->
<!--- relation inducted by subtyping)^[To keep things simple, we only consider --->
<!--- gradual list types, but all this section also applies to concrete types]: --->
We define list types as the set of types contained in the equivalence classes
(with respect to the equivalence relation inducted by the subtyping relation)
of the terms generated by the following grammar^[To keep things simple, we only
consider gradual list types, but all this section also applies to concrete
types]:

```
<l> ::= Nil
  | Cons(<τ>, <l>)
  | let <x> = <l> in <x>
  | <l> AND <l> | <l> $\vee$ <l>
  | ?
```

Those types are an encoding of Nix lists types which are the types of the form
`[ ρ ]`.

#### Compilation

It is quite naturally possible to go from list types in the Nix sense to list
types in the Nix-light sense. The compilation rules ar available in
\Cref{typage::listes::compilation}.

This compilation is the transposition of the compilation of regular expressions
to state machines.

\input{typing/lists-compilation}

#### Typing

The typing of lists is presented in \Cref{typage::liste}.

\begin{figure}
  \begin{displaymath}
    \inferrule{
      Γ \tIC e_1 : \tau_1 \\\\ Γ \tIC e_2 : \tau_2 \\\\
      \tau_2 \subtypeG \cons(\Any, \Any)
    }{
      Γ \tIC \cons(e_1, e_2) : \cons(\tau_1, \tau_2)
    }\lbl{Cons}
  \end{displaymath}
  \caption{Règle de typage des listes}\label{typage::liste}
\end{figure}
