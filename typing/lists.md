Unlike most languages, Nix-light does not have a "list" type. Lists are instead a
collection of types.
Indeed, lists are not homogeneous like they use to be but may contain elements
of arbitrary different types.

In Nix, they correspond to the types `[ρ]`^[To keep things simple, we only
consider gradual list types, but all this section also applies to concrete
types].
The regular expressions `ρ` describe the types of the elements of the list the
same way as a textual regular expression describes a family of characters
sequence.
For example, `[ Int* ]` is the type of (possibly empty )lists whose elements
are of type `Int`, `[ Bool Int* ]` the type of lists containing a boolean and
then an arbitrary number of integers and `[ (Bool+ | (Int String*)) Int? ]` is
the type of lists that contain either at least one boolean, or an integer
followed by any number of strings, and may end with an integer.

In Nix-light, we define list types as the set of types inductively generated by
the following grammar:

```
<l> ::= Nil
  | Cons(<τ>, <l>)
  | let <x> = <l> in <x>
  | <l> AND <l> | <l> $\vee$ <l>
  | ?
```

@Fri04 shows that these types can encode the regular expression list
types. The encoding is not reminded here as it is rather verbose (we just show
a couple of examples below), but it is essentially a transposition in the
domain of types of the compilation of regular expressions into finite
automatons.

For example, the type `[ Int* ]` is compiled to
`let X = Cons(Int, X) OR Nil in X`.
The type `[ (Int | Bool*) ]` is compiled to
`let X = Cons(Int, X) or Nil in X | Cons(Int, Nil)`.

#### Typing

The typing of lists  is presented in \Cref{typage::liste}.

\begin{figure}
  \begin{mathpar}
    \inferrule{
      Γ \tIC e_1 : \tau_1 \\\\ Γ \tIC e_2 : \tau_2 \\\\
      \tau_2 \subtypeG \cons(\Any, \Any)
    }{
      Γ \tIC \cons(e_1, e_2) : \cons(\tau_1, \tau_2)
    }\lbl{Cons}
    \and\inferrule{
      Γ \tinfer e : τ \\
      τ \subtypeG \cons(τ_1, τ_2)
    }{
      Γ \tIC \operatorname{Head}(e) : τ_1
    }\lbl{Head}
    \and\inferrule{
      Γ \tinfer e : τ \\
      τ \subtypeG \cons(τ_1, τ_2)
    }{
      Γ \tIC \operatorname{Tail}(e) : τ_2
    }\lbl{Tail}
  \end{mathpar}
  \caption{Typing rules for lists}\label{typage::liste}
\end{figure}
