\subsection{The $\λ\&-calculus$}

\subsubsection{Patterns}

In order to type patterns, we need to introduce a new form of typing judgement.
The judgement $\Γ \dashv p:\τ$ means that when applied against a type $\τ$, the
pattern $p$ will enrich the environment with the constraints $\Γ$.

For example, we got $x:\Int \dashv x:\Int$, which reads ``If we apply a term
of type $\Int$ to the pattern $x$, then the environment on the
right of the pattern will be enriched with the constraint $x:\Int$''

Likewise, the following statement holds.
\[x:\Int; y: \Bool \dashv \left\{ x; y ? \text{true}; \right\} : \{ x = \Int; y =? \Bool \}\]
This means that when if we match a term of type $\left\{ x =\Int; y =? \Bool
\right\}$ against the pattern $\left\{ x; y ? \text{true}; \right\}$, then the
environment on the right side of the pattern will be enriched with the
constraints $x : \Int$ and $y : \Bool$.

As the symbol ``$\dashv$'' suggests, this typing judgement is the converse of
the classical typing judgement $\Γ \vdash e : \τ$ for expressions: instead of
stating that under the hypothesis $\Γ$, the expression $e$ has type $\τ$, we
state that if the pattern $p$ has type $\τ$, then in produces the environment
$\Γ$.

The typing rules for this statement are given by the
figure~\pref{typing::patterns::typing-rules}.

Maybe~\todo{Find out wether this is true} this enjoys principal typing.

\todo{Define the projections $\pi_1$ and $\pi_2$}.

\begin{figure}
  \begin{mathpar}
    \inferrule{~}{x:\τ \dashv x:\τ}
    \and\inferrule{~}{\dashv \text{Nil} : \text{Nil}}
    \and\inferrule{\Γ \dashv p:\τ}{\Γ \dashv (p:\τ):\τ}
    \and\inferrule{%
      \τ \subtypeG \text{Cons}(\one,\one) \\
      \Γ_1 \dashv p_1 : \pi_1(\τ) \\
      \Γ_2 \dashv p_2 : \pi_2(\τ) \\
      \text{Vars}(\Γ_1) \cap \text{Vars}(\Γ_2) = \varnothing
    }{%
      \Γ_1; \Γ_2 \dashv \text{Cons}(p_1, p_2) : \τ
    }
    \and\inferrule{%
      \Γ \dashv p : \τ \\
      x \notin \Γ
    }{%
      \Γ; x:\τ \dashv p@x : \τ
    }
  \end{mathpar}
  \caption{Typing rules for the patterns\label{typing::patterns::typing-rules}}
\end{figure}

\subsubsection{Typecase}

The typecase $(x := e \in t) ? e_1 : e_2$ can be typed in a simple way, by
saying that if $e$ has a type $τ$, $e_1$ has type $\τ_1$ and $e_2$ has type
$\τ_2$ (under the current typing environment $\Γ$), then $(x := e \in t) ? e_1
: e_2$ has type $\τ_1 \vee \τ_2$.
However, doing so means that we do not use the extra type information given by
``$e \in t$'', which loosens a lot the interest of this construct. For example,
an expression such as $(x := e \in \bm{{Int}}) ? x + 1 : x$, with $\vdash e :
\any$ wouldn't typecheck, as $x+1$ isn't well typed without any further
constraint on the type of $x$.

A more interesting typing rule would state that if $\Γ; x:\τ \wedge t \vdash
e_1: \τ_1$ and $\Γ; x:\τ \wedge \lnot t \vdash e_2: \τ_2$ (where $\τ$ is a type
of $e$ under the hypothesis $\Γ$), then the whole expression has type $\τ_1
\vee \τ_2$.
With this rule, the expression $(x := e \in \bm{{Int}}) ? x + 1 : x$ is
well-typed (provided that $e$ is).

The typing rules are given by the
figures~\pref{typing::lambda-calculus},~\pref{typing::records}
and~\pref{typing::operators}.

\subsection{Bidirectional typing}

\subsubsection{Motivation and overview}
\label{motivation-and-overview}

The rules defined above are already quite expressive. However, they aren't
enough to type the following function, no matter how the type annotations are
written:

\begin{lstlisting}[language=NLight]
  (lambda cond. lambda x.  (y = cond in true) ? x+1 : not x
  : (true -> Int -> Int & false -> Bool -> Bool))
\end{lstlisting}

Indeed, do to this we would need to annotate $x$ as \ty{Int} or \ty{Bool}
depending on wether \texttt{cond} was \ty{true} or \ty{false}, which isn't
possible.

To remedy this problem, we split our type system in two parts: an inference
part and a checking part.  The inference part − denoted with typing judgements
of the form $\Γ \tinfer e : \τ$ − corresponds to classical bottom-up
type-inference, while the checking part − denoted with typing judgements of the
form $\Γ \tcheck e : \τ$ corresponds to a top-down type inference, where the
type of the expression is already known and we use it to infer the type of the
sub-expressions − in other words, we propagate the type annotations to the
bottom while type-checking. In particular, this ``checking'' type-system allows
us a more precise typing of lambdas.

Explicitly annotated let-bindings are thus typed using the checking type-system
and we can rewrite the previous expression as
\begin{lstlisting}[language=NLight]
let f : (true -> Int -> Int & false -> Bool -> Bool) =
 lambda cond. lambda x.  (y = cond tin true) ? x+1 : not x
in f
\end{lstlisting}

In this case, we just have to \emph{check} that
\begin{lstlisting}[language=NLight]
lambda x. (y = cond tin true) ? x+1 : not x
\end{lstlisting}
has type $\ty{Int} \rightarrow \ty{Int}$ under the hypothesis $\texttt{cond} :
\ty{true}$ and $\ty{Bool} \rightarrow \ty{Bool}$ under the hypothesis
$\texttt{cond} : \ty{false}$. This means checking that
\begin{lstlisting}[language=NLight]
(y = cond tin true) ? x+1 : not x
\end{lstlisting}
has type $\ty{Int}$ under the hypothesis $\texttt{cond} : \ty{true}; \texttt{x}
: \ty{Int}$ and $\ty{Bool}$ under the hypothesis $\texttt{cond} : \ty{false};
\texttt{x} : Bool$. This is true, thanks to the rules TcaseL and TcaseR of the
type system (figure~\pref{typing::lambda-calculus}).

So the basic idea behind this is to use the type annotations of parent nodes
(or any other type information that we got from upper in the AST), not just to
check that the inferred type was correct, but in the inference process itself.

\subsubsection{Pairs}\todo{Replace by lists}

For example, if we want to type the expression $(e_1, e_2) : (\τ_1 \times
\τ_2)$, we will try to type $(e_1 : \τ_1)$ and $(e_1 : \τ_2)$ and then merge
the results.
In a more general fashion, if we got $(e_1, e_2) : \τ$ − where $\τ$ is any
subtype of $\one \times \one$ − we will need to project $\τ$ on its first and
second component respectively to type $e_1$ and $e_2$.

We thus extends this definition of the projections $\pi_1$ and $\pi_2$ to more
complex pair types (\emph{ie.} subtypes of $\one \times \one$), keeping the
invariant that for a given subtype $\τ$ of $\one \times \one$, $\pi_1(\τ)
\times \pi_2(\τ)$ is a subtype~\todo{Gradual ?} of $\τ$, so that if $e_1$ has
type $\pi_1(\τ)$ and $e_2$ has type $\pi_2(\τ)$, then $(e_1, e_2)$ can be given
the type $\τ$.

Let $\τ$ be a subtype of $\one \times \one$.
We know that $\τ$ can be written as:
\[
  \τ = \bigvee\limits_{i\in I}\left(\bigwedge\limits_{p\in P_i} (\σ_p \times \τ_p)
  \wedge \bigwedge\limits_{n \in N_i} \lnot (\σ_n \times \τ_n) \right)
\]
We define $\pi_1(\τ)$ (resp. $\pi_2(\τ)$) as
\begin{align*}
  \pi_1(\τ) &= \bigwedge\limits_{i \in I} \bigwedge\limits_{N' \subseteq N}
    \left(\bigwedge\limits_{p \in P_i} \σ_p \wedge
    \bigwedge\limits_{n \in N'} \lnot \σ_n \right)\\
  \pi_2(\τ) &= \bigwedge\limits_{i \in I} \bigwedge\limits_{N' \subseteq N}
    \left(\bigwedge\limits_{p \in P_i} \τ_p \wedge
    \bigwedge\limits_{n \in N'} \lnot \τ_n \right)
\end{align*}

We can check\todo{Check that this is indeed true} that this definition respects
our constraint.

\subsubsection{Arrows}

Another construct for which we want to propagate type informations is the
definition of a function.

Assume we got an expression $(\λ p . e) : \τ$ where $\τ$ is a subtype (not
gradual) of $\zero \rightarrow \one$.

We want to type the function for each concrete arrow type included in $\τ$. In
other words, if we note $\A(\τ)$ the set of all arrow types in $\τ$, we want that
for all $\σ \rightarrow \σ' \in \A(\τ)$, $p$ matches $\σ$, and that under this
matching, $e$ has type $\σ'$.

This is given by the rule \emph{CAbs} of the type system in the
Figure~\pref{typing::lambda-calculus}.

Remains the definition of $\A(\τ)$, that we give as follows:

If $\τ$ is in the form
\[
  \τ = \bigvee\limits_{i\in I}\left(
    \bigwedge\limits_{p\in P_i} (\σ_p \rightarrow \τ_p)
    \wedge \bigwedge\limits_{n \in N_i} \lnot (\σ_n \rightarrow \τ_n)
  \right)
\]
then $\A(\τ)$ is given by:
\[
  \A(\τ) = \bigsqcap\limits_{i \in I} \{ \σ_p \rightarrow \τ_p \| p \in P_i \}
\]
where $\sqcap$ is defined as
\[
  \{ \σ_i \rightarrow \τ_i \| i \in I \} \sqcap \{ \σ_j \rightarrow \τ_j \| j \in J \} =
    \{ (\σ_i \wedge \σ_j) \rightarrow (\τ_i \vee \τ_j) \| i \in I, j \in J \}
\]

In the example of the Section~\ref{motivation-and-overview}, the expression has
type $t = (true \rightarrow (Int \rightarrow Int)) \wedge (false \rightarrow
(Bool \rightarrow Bool))$

Thus, we have $\A(t)$ equal to the set $\left\{ true \rightarrow (Int
\rightarrow Int); false \rightarrow (Bool \rightarrow Bool) \right\}$

\begin{figure}
  \input{typing/lambdaCalculus}
  \caption{Typing rules for the $\λ\&-calculus$\label{typing::lambda-calculus}\\
  \small{The ``$\delta$'' symbol means either ``$\Uparrow$'' either ``$\Downarrow$''
  (but always the same within a given inferrence rule)}}
\end{figure}
