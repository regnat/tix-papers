\subsubsection{Patterns}

In order to type patterns, we need to introduce a new form of typing judgement.
The judgement $\Γ \dashv p:\τ$ means that when applied against a type $\τ$, the
pattern $p$ will enrich the environment with the constraints $\Γ$.

For example, we got $x:\Int \dashv x:\Int$, which reads ``If we apply a term
of type $\Int$ to the pattern $x$, then the environment on the
right of the pattern will be enriched with the constraint $x:\Int$''

Likewise, the following statement holds.
\[x:\Int; y: \Bool \dashv \left\{ x; y ? \text{true}; \right\} : \{ x = \Int; y =? \Bool \}\]
This means that when if we match a term of type $\left\{ x =\Int; y =? \Bool
\right\}$ against the pattern $\left\{ x; y ? \text{true}; \right\}$, then the
environment on the right side of the pattern will be enriched with the
constraints $x : \Int$ and $y : \Bool$.

As the symbol ``$\dashv$'' suggests, this typing judgement is the converse of
the classical typing judgement $\Γ \vdash e : \τ$ for expressions: instead of
stating that under the hypothesis $\Γ$, the expression $e$ has type $\τ$, we
state that if the pattern $p$ has type $\τ$, then in produces the environment
$\Γ$.

The typing rules for this statement are given by the
figure~\pref{typing::patterns::typing-rules}.

Maybe~\todo{Find out wether this is true} this enjoys principal typing.

\todo{Define the projections $\pi_1$ and $\pi_2$}.

\begin{figure}
  \input{typing/inferenceRules/lambdaCalculus}
  \caption{Typing rules for the $\λ\&-calculus$\label{typing::lambda-calculus}\\
  \small{The ``$\delta$'' symbol means either ``$\Uparrow$'' either ``$\Downarrow$''
  (but always the same within a given inferrence rule)}}
\end{figure}

 \begin{figure}
  \begin{center}
    \begin{align*}
      \eqdefa{\accept{x}}{\grad}{}
      \eqdefa{\accept{x:\τ}}{\τ}{}
      \eqdefa{\accept{q@x}}{\accept{q}}{}
      \eqdefa{\accept{\cons(x_1, x_2)}}{\cons(\accept{x_1}, \accept{x_2})}{}
      \eqdefa{\accept{\cons(x_1, x_2) : \τ}}{%
        \accept{\cons(x_1 : \pi_1(\τ), x_2 : \pi_2(\τ))}
      }{\text{If }\τ \subtypeG Cons(\one, \one)}
      \eqdefa{\accept{\nil}}{\nil}{}
    \end{align*}
  \end{center}\label{typing::pattern-accept}
   \caption{Semantics of the $\accept{\_}$ operator}
\end{figure}
\begin{figure}
  \begin{mathpar}
    \inferrule{~}{x:\τ \dashv x:\τ}
    \and\inferrule{~}{\dashv \text{Nil} : \text{Nil}}
    \and\inferrule{\Γ \dashv p:\τ \\ \τ \subtypeG \σ}{\Γ \dashv (p:\σ):\τ}
    \and\inferrule{%
      \τ \subtypeG \cons(\one,\one) \\
      \Γ_1 \dashv p_1 : \pi_1(\τ) \\
      \Γ_2 \dashv p_2 : \pi_2(\τ) \\
      \text{Vars}(\Γ_1) \cap \text{Vars}(\Γ_2) = \varnothing
    }{%
      \Γ_1; \Γ_2 \dashv \cons(p_1, p_2) : \τ
    }
    \and\inferrule{%
      \Γ \dashv p : \τ \\
      x \notin \Γ
    }{%
      \Γ; x:\τ \dashv p@x : \τ
    }
  \end{mathpar}
  \caption{Typing rules for the patterns\label{typing::patterns::typing-rules}}
\end{figure}

\subsubsection{Typecase}

The typecase $(x := e \in t) ? e_1 : e_2$ can be typed in a simple way, by
saying that if $e$ has a type $τ$, $e_1$ has type $\τ_1$ and $e_2$ has type
$\τ_2$ (under the current typing environment $\Γ$), then $(x := e \in t) ? e_1
: e_2$ has type $\τ_1 \vee \τ_2$.
However, doing so means that we do not use the extra type information given by
``$e \in t$'', which loosens a lot the interest of this construct. For example,
an expression such as $(x := e \in \bm{{Int}}) ? x + 1 : x$, with $\vdash e :
\any$ wouldn't typecheck, as $x+1$ isn't well typed without any further
constraint on the type of $x$.

A more interesting typing rule would state that if $\Γ; x:\τ \wedge t \vdash
e_1: \τ_1$ and $\Γ; x:\τ \wedge \lnot t \vdash e_2: \τ_2$ (where $\τ$ is a type
of $e$ under the hypothesis $\Γ$), then the whole expression has type $\τ_1
\vee \τ_2$.
With this rule, the expression $(x := e \in \bm{{Int}}) ? x + 1 : x$ is
well-typed (provided that $e$ is).

The typing rules are given by the
figures~\pref{typing::lambda-calculus},~\pref{typing::records}
and~\pref{typing::operators}.
