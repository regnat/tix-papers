Both languages are rather similar, so the compilation is mostly
straightforward: nix lambdas are compiled to nix-light lambdas; nix constants,
and so on\ldots. The intersesting parts are:

\begin{itemize}
  \item[If-then-elses] Those are compiled, to typecases, as said in
    Section~\ref{sec:nix-light-grammar}. However, there are several
    possibilities for this.

    The obvious one is to translate \lstinline{if $e$ then $e_1$ else $e_2$} into
    \lstinline{($x$ := ($e$ : Bool) tin true) ? $e_1$ : $e_2$} (where $x$ do not appear
    free in $e_1$ or $e_2$).
    However, the interest of the typecase is that it gives us some information
    on the type of $x$, that we can't use at all here. So this translation
    isn't very interesting.
    When possible, we will  to define smarter compilations for some forms of
    if-then-else.

    The most notable pattern that we want to recognize is
    \lstinline{if isT $x$ then $e_1$ else $e_2$}
    (where \lstinline{isT} is a predicate on types such as
    \lstinline{isInt}, \lstinline{isBool}, \ldots).
    Such an expression would be compiled to a typecase of the form
    \lstinline{($x$ := $x$ tin T) ? $e_1$ : $e_2$}, which will later allow us to take
    advantage of the knowledge of the type of $x$.

  \item[Lists] Nix opaque lists are replaced in nix-light by the more
    conventional algebraic datatype built using the \lstinline{Cons} and
    \lstinline{Nil} constructors.
    This translation is rather easy: the compilation simply considers that
    \lstinline{[ $e_1$ $\cdots$ $e_n$ ]} is syntactic sugar for
    \lstinline{Cons($e_1$, Cons($\cdots$, Cons($e_n$, Nil)))} %chktex 36
\end{itemize}

The exact semantics of nix in term of nix-light are given by the
Figure~\pref{compilation}.
Some rules are overlapping for the compilation of the if-then-else
construct. In this case, the first one is the correct one (In fact, they all
have the same semantic meaning in nix-light, but they differ from a typing
point of view).

\begin{figure}
  \begin{align*}
    \sem{x} &= x \\
    \sem{c} &= c \\
    \sem{\λ p.e} &= \λ p. \sem{e} \\
    \sem{e_1\ e_2} &= \sem{e_1}\ \sem{e_2} \\
    \sem{\text{let } x_1 = e_1; \cdots; x_n = e_n; \text{ in } e} &=
      \text{let } x_1 = \sem{e_1}; \cdots; x_n = \sem{e_n};
        \text{ in } \sem{e} \\
    \sem{[e_1\ e_2\ \cdots\ e_n ]} &=
      \text{Cons}(\sem{e_1},\ \sem{[e_2\ \cdots\ e_n]}) \\
    \sem{[ e ]} &= \text{Cons}(\sem{e}, \text{Nil}) \\
    \sem{\text{if isT $x$ then $e_1$ else $e_2$}} &=
      (x := x \in T) ? e_1 : e_2 \\
    \sem{\text{if $e'_1$ || $e'_2$ then $e_1$ else $e_2$}} &=
      \sem{\text{if $e'1$ then $e_1$ else if $e'_2$ then $e_1$ else $e_2$}} \\
    \sem{\text{if $e'_1$ \&\& $e'_2$ then $e_1$ else $e_2$}} &=
      \sem{\text{if $e'1$ then if $e'_2$ then $e_1$ else $e_2$ else $e_2$}} \\
    \sem{\text{if not $e$ then $e_1$ else $e_2$}} &=
      \sem{\text{if $e$ then $e_2$ else $e_1$}} \\
    \sem{\text{if $e$ then $e_1$ else $e_2$}} &=
      (x := (\sem{e} : \text{Bool}) \in \text{true})\ ?\ \sem{e_1} : \sem{e_2} \\
  \end{align*}
  \caption{Semantics of the compilation from nix to nix-light}\label{compilation}
\end{figure}
