#### Grammar

Nix-light is similar to Nix, but makes syntactically distinct all the elements
which requires a special treatment from the typechecker.

The differences are:

- The if construct is replaced by the more general "typecase" construct of the
  form `(x = e0 tin t) ? e1 : e2` (which evaluates to `e1` if `e0` evaluates to
  a value of type `t` and to `e2` otherwise).
  The general case `if e0 then e1 else e2` will be compiled to
  `(x = (e0 : Bool) tin true) ? e1 : e2` (where `x` is a fresh variable),
  whereas particular cases such as `if isInt x then e1 else e2` will be compiled
  to specialized versions such as `(x = x tin Int) ? e1 : e2`.
  This lightens the type-system as both forms can be treated with the same rule.
  However, this reduces the expressiveness, as an expression such as `let f =
  isInt in if f x then x else 1` will not be recognized by the compiler
  (because it has no type information, so can not see that `f` is the same
  predicate over types as `isInt` and thus should be treated the same
  way)^[Typed racket [@FH08] does some tracking of type predicates in the
  type-system itself by annotating arrows. This can also be achieved (and in a
  less intrusive way) using this type-system and has in fact been implemented.
  This will be discussed in \Cref{implem::extensions}].

    The binding in `(x = e0 tin t) ? e1 : e2` is necessary to allow occurence
    typing (because we must refine the type of a variable, so we can't do
    anything on `e0` directly).

- The definition of records is simplified: Nix has a specific syntax to
  define nested records (for example `{ x.y = 1; x.z = 2; }` is equivalent to
  `{ x = { y = 1; z = 2; }; }`) which is absent in Nix-light.

- Recursive record definitions are not allowed either, they have to be encoded
  using a (recursive) let-binding.

- List types are replaced by the `Nil` and `Cons($\cdot$, $\cdot$)`
  constructors. The encoding is explained in \Cref{typing::structures::listes}.

Nix-light's grammar is given in
\Cref{nix-light::grammar,nix-light::grammar::values}.
The construct `<$\hat{t}$>` (denoting the types that appears in a typecase) is
a non-recursive version of `<t>` (so the typecase is in reality more something
like a "kind-case" which just checks for the head constuctor). The type
`Any$\vee \nabla$` represents an optional field (the reason for this notation
is explained in \Cref{typing::structures::records}).
Like in Nix, we impose an additional constraint on records which is that in a
record `{ x1 = e1; ...; xn = en }`, the labels `x1`, \ldots, `xn` must be
pairwise distinct.

#### Semantic

##### Pattern-matching

The pattern-matching in Nix-light has a rather classical semantic for a lazy
language, with the simplification that as patterns are not recursive, the
argument is either non-evaluated at all, or evaluated in head normal form.

\newcommand{\var}{\mathcal{V}}
If `r` is a variable pattern − hence in the form `x` or `x:τ` where `x` is an
ident and `τ` a type − we define the variable represented by `r` (that we note
$\var(r)$) as $\var(x) = \var(x:τ) = x$.
We extend this defintion to a record pattern field `l` (of the form `r` or
`r?c` where `c` is a constant) by stating that $\var(r ? c) = \var(r)$.
In what follows, `l` denotes a record-pattern field of the form `r` or `r?c`
(where `c` is a constant).

For a pattern `p` and a value `v` (resp. an expression `e`), we note
$\sfrac{p}{v}$ the substitution generated by the matching of `v` (resp. `e`)
against `p`.
It is defined in \Cref{nix-light::pattern-matching}.
The basic idea from which all the rules derive is that the matching of any
expression `e` against a variable pattern will produce the substitution `x :=
e` and that the matching of a record value `{ x1 = e1; ...; xn = en }` against
a record pattern `p` with fields `x1`, \ldots, `xn` will produce the
substitution `x1 := e1; ...; xn := en`.

##### Operational semantic

The full semantic is given in \Cref{nix-light::semantics}.

The reduction rules should be self-explanatory.
The only worth mentioning are the two rules for the typecase, which involve a
typing judgement (and thus make the semantics typing dependent). This typing
judgement is however very simple at it simply checks the toplevel constructor
of the given value. Its definition is given in annex at the
\Cref{nix-light::typecase-typing}.
