\begin{figure}[H]
  \begin{displaymath}
    \flatten\left(\left\{ \seq{ apf_i = e_i;}{i \in I};
      \seq{\seq{apf_j.ap_k = e_k}{k \in K_j}}{j \in J} \right\}\right) =
      \left\{ \seq{ apf_i = e_i;}{i \in I}; \seq{ apf_j =
        \flatten\left(\left\{ \seq{ap_k = e_k;}{k \in K_j} \right\}\right)
        }{j \in J} \right\}
    \end{displaymath}
    \center
    Where the $apf$'s denote constructs of the form °<access-path-field>°
    and the $ap$'s constructs of the form °<access-path>°.
    We furthermore assume that the $apf_i$'s and $apf_j$'s are pairwise distinct
    (we consider that two access paths fields of the form °DOLLAR{e}° are always
     distinct).
    \caption{Definition of the $\flatten$ function on records\label{compilation::flatten}}
\end{figure}
\begin{figure}[H]
  \begin{displaymath}
    \derec\left(\text{ rec }\left\{ \seq{x_i = e_i }{i \in I} \right\}\right) =
      \text{let } \seq{x'_i = e'_i}{i \in I} \text{ in }
      \left\{ \seq{x_i = x'_i}{i \in I} \right\}
  \end{displaymath}

  \center Where the $x'_i$'s are fresh variables and each $e'_i$ is equal to
  $e_i\left[\seq{x_i := x'_i}{i \in I}\right]$.
  \caption{Definition of the $\derec$ function on records\label{compilation::derec}}
\end{figure}

\begin{figure}[H]
  \begin{tabular}{ll}
    °(|x|)° &= °x° \\
    °(|c|)° &= °c°\\
    °(|λp.e|)° &= °λ(|p|).(|e|)°\\
    °(|e1 e2|)° &= °(|e1|) (|e2|)°\\
    °(|let v1 = e1; $\cdots$; vn = en; in e|)° &=
      °let v1 = (|e1|); $\cdots$; vn = (|en|); in (|e|)°\\
    °(|[ e1 $\cdots$ en ]|)° &= °[(|e1|) $\cdots$ (|en|)]°\\
    °(|{ ap1 = e1; ...; apn = en }|)° &= °$\flatten$({ (|ap1|) = (|e1|); ...; (|apn|) = (|en|) })°\\
    °(|rec { record }|)° &= °$\derec$((|{ record }|))°\\
    °(|if isT x then e1 else e2|)° &= °(x = x tin T) ? (|e1|) : (|e2|)°\\
    °(|if e0 then e1 else e2|)° &=
      °(x = ((|e0|) : Bool) tin true) ? (|e1|) : (|e2|)°\\
    &{\itshape
      if °e0° is not of the form °isT y°;
      with °x° a fresh variable} \\
    °(|e.apf1. $\cdots$ . apfn|)° &= °(|e|).(||apf1||). $\cdots$ .(||apfn||)°\\
    °(|e1.ap or e2|)° &= °(|e1.ap|) or (|e2|)°\\
    °(|e1 op e2|)° &= °(|e1|) op (|e2|)°\\
    °(|e : τ|)° &= °(|e|) : (|τ|)°\\

    °(||DOLLAR{e}||)° &= °(|e|)°\\
    °(||x||)° &= °"x"°
  \end{tabular}
  \caption{Compilation from Nix to Nix-light}\label{nix-light::compilation}
\end{figure}

\begin{figure}[H]
  \begin{tabular}{ll}
    °if e1|e2 then $e_{if}$ else $e_{then}$°
      &$\rightarrow$ °if e1 then $e_{if}$ else (if e2 then $e_{if}$ else $e_{then}$)° \\
    °if e1&e2 then $e_{if}$ else $e_{then}$°
      &$\rightarrow$ °if e1 then (if e2 then $e_{if}$ else $e_{then}$) else $e_{if}$° \\
    °if not e then $e_{if}$ else $e_{then}$°
      &$\rightarrow$ °if e then $e_{then}$ else $e_{if}$°
  \end{tabular}
  \caption{Preprocessing of Nix conditionals}\label{nix-light::preprocessing}
\end{figure}
