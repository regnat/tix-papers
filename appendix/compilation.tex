\begin{figure}[H]
  \begin{displaymath}
    \flatten\left(\left\{ \seq{ apf_i = e_i;}{i \in I};
      \seq{\seq{apf_j.ap_k = e_k}{k \in K_j}}{j \in J} \right\}\right) =
      \left\{ \seq{ apf_i = e_i;}{i \in I}; \seq{ apf_j =
        \flatten\left(\left\{ \seq{ap_k = e_k;}{k \in K_j} \right\}\right)
        }{j \in J} \right\}
    \end{displaymath}
    \center
    Where the $apf$'s denote constructs of the form °<access-path-field>°
    and the $ap$'s constructs of the form °<access-path>°.
    We furthermore assume that the $apf_i$'s and $apf_j$'s are pairwise distinct
    (we consider that two access paths fields of the form °DOLLAR{e}° are always
     distinct).
    \caption{Definition of the $\flatten$ function on records\label{compilation::flatten}}
\end{figure}
\begin{figure}[H]
  \begin{displaymath}
    \derec\left(\text{ rec }\left\{ \seq{x_i = e_i }{i \in I} \right\}\right) =
      \text{let } \seq{x'_i = e'_i}{i \in I} \text{ in }
      \left\{ \seq{x_i = x'_i}{i \in I} \right\}
  \end{displaymath}

  \center Where the $x'_i$'s are fresh variables and each $e'_i$ is equal to
  $e_i\left[\seq{x_i := x'_i}{i \in I}\right]$.
  \caption{Definition of the $\derec$ function on records\label{compilation::derec}}
\end{figure}

\begin{figure}[H]
  \begin{tabular}{ll}
    °(|x|)° &= °x° \\
    °(|c|)° &= °c°\\
    °(|λp.e|)° &= °λ(|p|).(|e|)°\\
    °(|$e_1$ $e_2$|)° &= °(|$e_1$|) (|$e_2$|)°\\
    °(|let $v_1$ = $e_1$; $\cdots$; $v_n$ = $e_n$; in e|)° &=
      °let $v_1$ = (|$e_1$|); $\cdots$; $v_n$ = (|$e_n$|); in (|e|)°\\
    °(|[ $e_1$ $\cdots$ $e_n$ ]|)° &= °[(|$e_1$|) $\cdots$ (|$e_n$|)]°\\
    °(|{ $ap_1$ = $e_1$; ...; $ap_n$ = $e_n$ }|)°
      &= °$\flatten$({ (|$ap_1$|) = (|$e_1$|); ...; (|$ap_n$|) = (|$e_n$|) })°\\
    °(|rec { record }|)° &= °$\derec$((|{ record }|))°\\
    °(|if isT x then $e_1$ else $e_2$|)° &= °(x = x tin T) ? (|$e_1$|) : (|$e_2$|)°\\
    °(|if $e_0$ then $e_1$ else $e_2$|)° &=
      °(x = ((|$e_0$|) : Bool) tin true) ? (|$e_1$|) : (|$e_2$|)°\\
    &{\itshape
      if °$e_0$° is not of the form °isT y°;
      with °x° a fresh variable} \\
    °(|e.$apf_1$. $\cdots$ . $apf_n$|)° &= °(|e|).(||$apf_1$||). $\cdots$ .(||$apf_n$||)°\\
    °(|$e_1$.ap or $e_2$|)° &= °(|$e_1$.ap|) or (|$e_2$|)°\\
    °(|$e_1$ op $e_2$|)° &= °(|$e_1$|) op (|$e_2$|)°\\
    °(|e : τ|)° &= °(|e|) : (|τ|)°\\

    °(||DOLLAR{e}||)° &= °(|e|)°\\
    °(||x||)° &= °"x"°
  \end{tabular}
  \caption{Compilation from Nix to Nix-light}\label{nix-light::compilation}
\end{figure}

\begin{figure}[H]
  \begin{tabular}{ll}
    °if $e_1$|$e_2$ then $e_{if}$ else $e_{then}$°
      &$\rightarrow$ °if $e_1$ then $e_{if}$ else (if $e_2$ then $e_{if}$ else $e_{then}$)° \\
    °if $e_1$&$e_2$ then $e_{if}$ else $e_{then}$°
      &$\rightarrow$ °if $e_1$ then (if $e_2$ then $e_{if}$ else $e_{then}$) else $e_{if}$° \\
    °if not e then $e_{if}$ else $e_{then}$°
      &$\rightarrow$ °if e then $e_{then}$ else $e_{if}$°
  \end{tabular}
  \caption{Preprocessing of Nix conditionals}\label{nix-light::preprocessing}
\end{figure}
